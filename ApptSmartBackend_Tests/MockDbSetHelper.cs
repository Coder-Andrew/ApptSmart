using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Moq;

// This was generated by Claude 3.7 Sonnet

/// <summary>
/// Helper class for mocking Entity Framework Core DbSets for unit testing
/// </summary>
public static class MockDbSetHelper
{
    /// <summary>
    /// Creates a mock DbSet that supports both synchronous and asynchronous operations
    /// </summary>
    /// <typeparam name="T">Entity type of the DbSet</typeparam>
    /// <param name="sourceList">The source data for the mock DbSet</param>
    /// <returns>A mock DbSet that can be used in unit tests</returns>
    public static Mock<DbSet<T>> CreateMockDbSet<T>(IEnumerable<T> sourceList) where T : class
    {
        var queryable = sourceList.AsQueryable();
        var dbSetMock = new Mock<DbSet<T>>();

        // Set up for synchronous operations
        dbSetMock.As<IQueryable<T>>().Setup(m => m.Provider).Returns(queryable.Provider);
        dbSetMock.As<IQueryable<T>>().Setup(m => m.Expression).Returns(queryable.Expression);
        dbSetMock.As<IQueryable<T>>().Setup(m => m.ElementType).Returns(queryable.ElementType);
        dbSetMock.As<IQueryable<T>>().Setup(m => m.GetEnumerator()).Returns(queryable.GetEnumerator());

        // Set up for asynchronous operations
        dbSetMock.As<IAsyncEnumerable<T>>().Setup(m => m.GetAsyncEnumerator(It.IsAny<CancellationToken>()))
            .Returns(new TestAsyncEnumerator<T>(queryable.GetEnumerator()));

        // Set up for Find and FindAsync
        dbSetMock.Setup(m => m.Find(It.IsAny<object[]>()))
            .Returns<object[]>(ids => queryable.FirstOrDefault(GetLambdaForFindPredicate<T>(ids)));

        dbSetMock.Setup(m => m.FindAsync(It.IsAny<object[]>()))
            .Returns<object[]>(ids =>
            {
                var result = queryable.FirstOrDefault(GetLambdaForFindPredicate<T>(ids));
                return ValueTask.FromResult(result);
            });

        // Set up for Add and AddAsync
        dbSetMock.Setup(d => d.Add(It.IsAny<T>())).Callback<T>(item => sourceList.ToList().Add(item));

        dbSetMock.Setup(d => d.AddAsync(It.IsAny<T>(), It.IsAny<CancellationToken>()))
            .Returns<T, CancellationToken>((entity, token) =>
            {
                sourceList.ToList().Add(entity);
                return ValueTask.FromResult(Mock.Of<EntityEntry<T>>());
            });

        return dbSetMock;
    }

    /// <summary>
    /// Creates a dynamic predicate for the Find method based on primary keys
    /// </summary>
    /// <remarks>
    /// This is a simplified implementation that works for common scenarios.
    /// For complex primary keys or custom configurations, you might need to adjust this.
    /// </remarks>
    private static Func<T, bool> GetLambdaForFindPredicate<T>(object[] ids) where T : class
    {
        // This is a simplified implementation - assumes first property is the Id
        // For complex keys, you would need to enhance this
        return entity =>
        {
            try
            {
                var idProperty = typeof(T).GetProperties().FirstOrDefault();

                if (idProperty == null)
                    return false;

                var idValue = idProperty.GetValue(entity);
                return idValue != null && idValue.Equals(ids[0]);
            }
            catch
            {
                return false;
            }
        };
    }
}

/// <summary>
/// Helper class that simplifies the setup of mocked DbContexts
/// </summary>
public static class MockDbContextHelper
{
    /// <summary>
    /// Sets up a DbSet property on a mocked DbContext
    /// </summary>
    /// <typeparam name="TContext">Type of the DbContext</typeparam>
    /// <typeparam name="TEntity">Type of the entity in the DbSet</typeparam>
    /// <param name="mockContext">The mock DbContext</param>
    /// <param name="dbSetSelector">Expression to access the DbSet property</param>
    /// <param name="sourceData">The source data for the DbSet</param>
    public static void SetupDbSet<TContext, TEntity>(
        Mock<TContext> mockContext,
        Expression<Func<TContext, DbSet<TEntity>>> dbSetSelector,
        IEnumerable<TEntity> sourceData)
        where TContext : class
        where TEntity : class
    {
        var mockDbSet = MockDbSetHelper.CreateMockDbSet(sourceData);
        mockContext.Setup(dbSetSelector).Returns(mockDbSet.Object);
    }

    /// <summary>
    /// Creates a fully mocked DbContext with all DbSets configured
    /// </summary>
    /// <typeparam name="TContext">Type of the DbContext</typeparam>
    /// <param name="configureContext">Action to configure the mock context</param>
    /// <returns>A mock DbContext</returns>
    public static Mock<TContext> CreateMockDbContext<TContext>(Action<MockDbContextBuilder<TContext>> configureContext)
        where TContext : class
    {
        var mockContext = new Mock<TContext>();
        var builder = new MockDbContextBuilder<TContext>(mockContext);
        configureContext(builder);

        // We can't directly set up SaveChanges methods on a generic TContext
        // since it might not have these methods. The caller should set up these
        // methods if needed using the returned mock.

        return mockContext;
    }
}

/// <summary>
/// Builder class for configuring a mock DbContext
/// </summary>
/// <typeparam name="TContext">Type of the DbContext</typeparam>
public class MockDbContextBuilder<TContext> where TContext : class
{
    private readonly Mock<TContext> _mockContext;

    public MockDbContextBuilder(Mock<TContext> mockContext)
    {
        _mockContext = mockContext ?? throw new ArgumentNullException(nameof(mockContext));
    }

    /// <summary>
    /// Sets up a DbSet property on the mock DbContext
    /// </summary>
    /// <typeparam name="TEntity">Type of the entity in the DbSet</typeparam>
    /// <param name="dbSetSelector">Expression to access the DbSet property</param>
    /// <param name="sourceData">The source data for the DbSet</param>
    /// <returns>The builder for method chaining</returns>
    public MockDbContextBuilder<TContext> WithDbSet<TEntity>(
        Expression<Func<TContext, DbSet<TEntity>>> dbSetSelector,
        IEnumerable<TEntity> sourceData)
        where TEntity : class
    {
        var mockDbSet = MockDbSetHelper.CreateMockDbSet(sourceData);
        _mockContext.Setup(dbSetSelector).Returns(mockDbSet.Object);
        return this;
    }

    /// <summary>
    /// Sets up SaveChanges and SaveChangesAsync methods if the context has them
    /// </summary>
    /// <param name="returnValue">The value to return from SaveChanges</param>
    /// <returns>The builder for method chaining</returns>
    public MockDbContextBuilder<TContext> WithSaveChanges(int returnValue = 1)
    {
        // Only set up these methods if the context type has them
        if (typeof(TContext).GetMethod("SaveChanges", Type.EmptyTypes) != null)
        {
            _mockContext.Setup(m => ((DbContext)(object)m).SaveChanges()).Returns(returnValue);
        }

        if (typeof(TContext).GetMethod("SaveChangesAsync", new[] { typeof(CancellationToken) }) != null)
        {
            _mockContext.Setup(m => ((DbContext)(object)m).SaveChangesAsync(It.IsAny<CancellationToken>()))
                .ReturnsAsync(returnValue);
        }

        return this;
    }

    /// <summary>
    /// Gets the configured mock context
    /// </summary>
    public Mock<TContext> MockContext => _mockContext;
}

/// <summary>
/// Extension methods for mocking Entity Framework Core DbContexts
/// </summary>
public static class MockDbContextExtensions
{
    /// <summary>
    /// Sets up SaveChanges and SaveChangesAsync methods for a DbContext
    /// </summary>
    /// <typeparam name="TContext">Type of the DbContext</typeparam>
    /// <param name="mockContext">The mock DbContext</param>
    /// <param name="returnValue">The value to return from SaveChanges</param>
    /// <returns>The mock context for method chaining</returns>
    public static Mock<TContext> SetupSaveChanges<TContext>(this Mock<TContext> mockContext, int returnValue = 1)
        where TContext : DbContext
    {
        mockContext.Setup(m => m.SaveChanges()).Returns(returnValue);
        mockContext.Setup(m => m.SaveChangesAsync(It.IsAny<CancellationToken>())).ReturnsAsync(returnValue);
        return mockContext;
    }
}